{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTransparentExprWrapper = isTransparentExprWrapper;\nexports.skipTransparentExprWrapperNodes = skipTransparentExprWrapperNodes;\nexports.skipTransparentExprWrappers = skipTransparentExprWrappers;\nvar _t = require(\"@babel/types\");\nconst {\n  isParenthesizedExpression,\n  isTSAsExpression,\n  isTSNonNullExpression,\n  isTSSatisfiesExpression,\n  isTSTypeAssertion,\n  isTypeCastExpression\n} = _t;\nfunction isTransparentExprWrapper(node) {\n  return isTSAsExpression(node) || isTSSatisfiesExpression(node) || isTSTypeAssertion(node) || isTSNonNullExpression(node) || isTypeCastExpression(node) || isParenthesizedExpression(node);\n}\nfunction skipTransparentExprWrappers(path) {\n  while (isTransparentExprWrapper(path.node)) {\n    path = path.get(\"expression\");\n  }\n  return path;\n}\nfunction skipTransparentExprWrapperNodes(node) {\n  while (isTransparentExprWrapper(node)) {\n    node = node.expression;\n  }\n  return node;\n}","map":{"version":3,"names":["_t","require","isParenthesizedExpression","isTSAsExpression","isTSNonNullExpression","isTSSatisfiesExpression","isTSTypeAssertion","isTypeCastExpression","isTransparentExprWrapper","node","skipTransparentExprWrappers","path","get","skipTransparentExprWrapperNodes","expression"],"sources":["../src/index.ts"],"sourcesContent":["import {\n  isParenthesizedExpression,\n  isTSAsExpression,\n  isTSNonNullExpression,\n  isTSSatisfiesExpression,\n  isTSTypeAssertion,\n  isTypeCastExpression,\n} from \"@babel/types\";\n\nimport type * as t from \"@babel/types\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport type TransparentExprWrapper =\n  | t.TSAsExpression\n  | t.TSSatisfiesExpression\n  | t.TSTypeAssertion\n  | t.TSNonNullExpression\n  | t.TypeCastExpression\n  | t.ParenthesizedExpression;\n\n// A transparent expression wrapper is an AST node that most plugins will wish\n// to skip, as its presence does not affect the behaviour of the code. This\n// includes expressions used for types, and extra parenthesis. For example, in\n// (a as any)(), this helper can be used to skip the TSAsExpression when\n// determining the callee.\nexport function isTransparentExprWrapper(\n  node: t.Node,\n): node is TransparentExprWrapper {\n  return (\n    isTSAsExpression(node) ||\n    isTSSatisfiesExpression(node) ||\n    isTSTypeAssertion(node) ||\n    isTSNonNullExpression(node) ||\n    isTypeCastExpression(node) ||\n    isParenthesizedExpression(node)\n  );\n}\n\nexport function skipTransparentExprWrappers(\n  path: NodePath<t.Expression>,\n): NodePath<t.Expression> {\n  while (isTransparentExprWrapper(path.node)) {\n    path = path.get(\"expression\");\n  }\n  return path;\n}\n\nexport function skipTransparentExprWrapperNodes(\n  node: t.Expression | t.Super,\n): t.Expression | t.Super {\n  while (isTransparentExprWrapper(node)) {\n    node = node.expression;\n  }\n  return node;\n}\n"],"mappings":";;;;;;;;AAAA,IAAAA,EAAA,GAAAC,OAAA;;EACEC,yB;EACAC,gB;EACAC,qB;EACAC,uB;EACAC,iB;EACAC;;AAmBK,SAASC,wBAATA,CACLC,IADK,EAE2B;EAChC,OACEN,gBAAgB,CAACM,IAAD,CAAhB,IACAJ,uBAAuB,CAACI,IAAD,CADvB,IAEAH,iBAAiB,CAACG,IAAD,CAFjB,IAGAL,qBAAqB,CAACK,IAAD,CAHrB,IAIAF,oBAAoB,CAACE,IAAD,CAJpB,IAKAP,yBAAyB,CAACO,IAAD,CAN3B;AAQD;AAEM,SAASC,2BAATA,CACLC,IADK,EAEmB;EACxB,OAAOH,wBAAwB,CAACG,IAAI,CAACF,IAAN,CAA/B,EAA4C;IAC1CE,IAAI,GAAGA,IAAI,CAACC,GAAL,CAAS,YAAT,CAAP;EACD;EACD,OAAOD,IAAP;AACD;AAEM,SAASE,+BAATA,CACLJ,IADK,EAEmB;EACxB,OAAOD,wBAAwB,CAACC,IAAD,CAA/B,EAAuC;IACrCA,IAAI,GAAGA,IAAI,CAACK,UAAZ;EACD;EACD,OAAOL,IAAP;AACD"},"metadata":{},"sourceType":"script"}