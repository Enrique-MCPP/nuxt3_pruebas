{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.error.cause.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\nvar _assert = require(\"assert\");\nvar _t = require(\"@babel/types\");\nvar _template = require(\"@babel/template\");\nvar _helperSimpleAccess = require(\"@babel/helper-simple-access\");\nconst {\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  getOuterBindingIdentifiers,\n  identifier,\n  isMemberExpression,\n  isVariableDeclaration,\n  jsxIdentifier,\n  jsxMemberExpression,\n  memberExpression,\n  numericLiteral,\n  sequenceExpression,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\nfunction isInType(path) {\n  do {\n    switch (path.parent.type) {\n      case \"TSTypeAnnotation\":\n      case \"TSTypeAliasDeclaration\":\n      case \"TSTypeReference\":\n      case \"TypeAnnotation\":\n      case \"TypeAlias\":\n        return true;\n      case \"ExportSpecifier\":\n        return path.parentPath.parent.exportKind === \"type\";\n      default:\n        if (path.parentPath.isStatement() || path.parentPath.isExpression()) {\n          return false;\n        }\n    }\n  } while (path = path.parentPath);\n}\nfunction rewriteLiveReferences(programPath, metadata) {\n  const imported = new Map();\n  const exported = new Map();\n  const requeueInParent = path => {\n    programPath.requeue(path);\n  };\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n    exportMeta.push(...data.names);\n  }\n  const rewriteBindingInitVisitorState = {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported\n  };\n  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);\n  (0, _helperSimpleAccess.default)(programPath, new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]), false);\n  const rewriteReferencesVisitorState = {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported,\n    exported,\n    buildImportReference: ([source, importName, localName], identNode) => {\n      const meta = metadata.source.get(source);\n      meta.referenced = true;\n      if (localName) {\n        if (meta.lazy) {\n          identNode = callExpression(identNode, []);\n        }\n        return identNode;\n      }\n      let namespace = identifier(meta.name);\n      if (meta.lazy) namespace = callExpression(namespace, []);\n      if (importName === \"default\" && meta.interop === \"node-default\") {\n        return namespace;\n      }\n      const computed = metadata.stringSpecifiers.has(importName);\n      return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);\n    }\n  };\n  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);\n}\nconst rewriteBindingInitVisitor = {\n  Scope(path) {\n    path.skip();\n  },\n  ClassDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    const {\n      id\n    } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n    const exportNames = exported.get(localName) || [];\n    if (exportNames.length > 0) {\n      const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName), path.scope));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n  VariableDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {\n      const exportNames = exported.get(localName) || [];\n      if (exportNames.length > 0) {\n        const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName), path.scope));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n};\nconst buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr, scope) => {\n  const exportsObjectName = metadata.exportName;\n  for (let currentScope = scope; currentScope != null; currentScope = currentScope.parent) {\n    if (currentScope.hasOwnBinding(exportsObjectName)) {\n      currentScope.rename(exportsObjectName);\n    }\n  }\n  return (exportNames || []).reduce((expr, exportName) => {\n    const {\n      stringSpecifiers\n    } = metadata;\n    const computed = stringSpecifiers.has(exportName);\n    return assignmentExpression(\"=\", memberExpression(identifier(exportsObjectName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);\n  }, localExpr);\n};\nconst buildImportThrow = localName => {\n  return _template.default.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\nconst rewriteReferencesVisitor = {\n  ReferencedIdentifier(path) {\n    const {\n      seen,\n      buildImportReference,\n      scope,\n      imported,\n      requeueInParent\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const localName = path.node.name;\n    const importData = imported.get(localName);\n    if (importData) {\n      if (isInType(path)) {\n        throw path.buildCodeFrameError(`Cannot transform the imported binding \"${localName}\" since it's also used in a type annotation. ` + `Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);\n      }\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = scope.getBinding(localName);\n      if (rootBinding !== localBinding) return;\n      const ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && isMemberExpression(ref)) {\n        path.replaceWith(sequenceExpression([numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {\n        const {\n          object,\n          property\n        } = ref;\n        path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n  UpdateExpression(path) {\n    const {\n      scope,\n      seen,\n      imported,\n      exported,\n      requeueInParent,\n      buildImportReference\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const arg = path.get(\"argument\");\n    if (arg.isMemberExpression()) return;\n    const update = path.node;\n    if (arg.isIdentifier()) {\n      const localName = arg.node.name;\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n      const exportedNames = exported.get(localName);\n      const importData = imported.get(localName);\n      if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n        if (importData) {\n          path.replaceWith(assignmentExpression(update.operator[0] + \"=\", buildImportReference(importData, arg.node), buildImportThrow(localName)));\n        } else if (update.prefix) {\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, cloneNode(update), path.scope));\n        } else {\n          const ref = scope.generateDeclaredUidIdentifier(localName);\n          path.replaceWith(sequenceExpression([assignmentExpression(\"=\", cloneNode(ref), cloneNode(update)), buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName), path.scope), cloneNode(ref)]));\n        }\n      }\n    }\n    requeueInParent(path);\n    path.skip();\n  },\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference\n      } = this;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n      if (left.isIdentifier()) {\n        const localName = left.node.name;\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          _assert(path.node.operator === \"=\", \"Path was not simplified\");\n          const assignment = path.node;\n          if (importData) {\n            assignment.left = buildImportReference(importData, left.node);\n            assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment, path.scope));\n          requeueInParent(path);\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(localName => scope.getBinding(localName) === path.scope.getBinding(localName));\n        const id = programScopeIds.find(localName => imported.has(localName));\n        if (id) {\n          path.node.right = sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n        const items = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName), path.scope));\n          }\n        });\n        if (items.length > 0) {\n          let node = sequenceExpression(items);\n          if (path.parentPath.isExpressionStatement()) {\n            node = expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n  },\n  \"ForOfStatement|ForInStatement\"(path) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      left\n    } = node;\n    const {\n      exported,\n      imported,\n      scope: programScope\n    } = this;\n    if (!isVariableDeclaration(left)) {\n      let didTransformExport = false,\n        importConstViolationName;\n      const loopBodyScope = path.get(\"body\").scope;\n      for (const name of Object.keys(getOuterBindingIdentifiers(left))) {\n        if (programScope.getBinding(name) === scope.getBinding(name)) {\n          if (exported.has(name)) {\n            didTransformExport = true;\n            if (loopBodyScope.hasOwnBinding(name)) {\n              loopBodyScope.rename(name);\n            }\n          }\n          if (imported.has(name) && !importConstViolationName) {\n            importConstViolationName = name;\n          }\n        }\n      }\n      if (!didTransformExport && !importConstViolationName) {\n        return;\n      }\n      path.ensureBlock();\n      const bodyPath = path.get(\"body\");\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      path.get(\"left\").replaceWith(variableDeclaration(\"let\", [variableDeclarator(cloneNode(newLoopId))]));\n      scope.registerDeclaration(path.get(\"left\"));\n      if (didTransformExport) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(assignmentExpression(\"=\", left, newLoopId)));\n      }\n      if (importConstViolationName) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(buildImportThrow(importConstViolationName)));\n      }\n    }\n  }\n};","map":{"version":3,"names":["_assert","require","_t","_template","_helperSimpleAccess","assignmentExpression","callExpression","cloneNode","expressionStatement","getOuterBindingIdentifiers","identifier","isMemberExpression","isVariableDeclaration","jsxIdentifier","jsxMemberExpression","memberExpression","numericLiteral","sequenceExpression","stringLiteral","variableDeclaration","variableDeclarator","isInType","path","parent","type","parentPath","exportKind","isStatement","isExpression","rewriteLiveReferences","programPath","metadata","imported","Map","exported","requeueInParent","requeue","source","data","localName","importName","imports","set","importsNamespace","local","exportMeta","get","push","names","rewriteBindingInitVisitorState","scope","traverse","rewriteBindingInitVisitor","default","Set","Array","from","keys","rewriteReferencesVisitorState","seen","WeakSet","buildImportReference","identNode","meta","referenced","lazy","namespace","name","interop","computed","stringSpecifiers","has","rewriteReferencesVisitor","Scope","skip","ClassDeclaration","id","node","Error","exportNames","length","statement","buildBindingExportAssignmentExpression","_blockHoist","insertAfter","VariableDeclaration","Object","forEach","localExpr","exportsObjectName","exportName","currentScope","hasOwnBinding","rename","reduce","expr","buildImportThrow","expression","ast","ReferencedIdentifier","add","importData","buildCodeFrameError","localBinding","getBinding","rootBinding","ref","loc","isCallExpression","callee","isOptionalCallExpression","isTaggedTemplateExpression","tag","replaceWith","isJSXIdentifier","object","property","UpdateExpression","arg","update","isIdentifier","exportedNames","operator","prefix","generateDeclaredUidIdentifier","AssignmentExpression","exit","left","assignment","right","ids","programScopeIds","filter","find","items","isExpressionStatement","ForOfStatement|ForInStatement","programScope","didTransformExport","importConstViolationName","loopBodyScope","ensureBlock","bodyPath","newLoopId","generateUidIdentifierBasedOnNode","registerDeclaration","unshiftContainer"],"sources":["../src/rewrite-live-references.ts"],"sourcesContent":["import assert from \"assert\";\nimport {\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  getOuterBindingIdentifiers,\n  identifier,\n  isMemberExpression,\n  isVariableDeclaration,\n  jsxIdentifier,\n  jsxMemberExpression,\n  memberExpression,\n  numericLiteral,\n  sequenceExpression,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport template from \"@babel/template\";\nimport type { NodePath, Visitor, Scope } from \"@babel/traverse\";\nimport simplifyAccess from \"@babel/helper-simple-access\";\n\nimport type { ModuleMetadata } from \"./normalize-and-load-metadata\";\n\ninterface RewriteReferencesVisitorState {\n  exported: Map<any, any>;\n  metadata: ModuleMetadata;\n  requeueInParent: (path: NodePath) => void;\n  scope: Scope;\n  imported: Map<any, any>;\n  buildImportReference: (\n    [source, importName, localName]: readonly [string, string, string],\n    identNode: t.Identifier | t.CallExpression | t.JSXIdentifier,\n  ) => any;\n  seen: WeakSet<object>;\n}\n\ninterface RewriteBindingInitVisitorState {\n  exported: Map<any, any>;\n  metadata: ModuleMetadata;\n  requeueInParent: (path: NodePath) => void;\n  scope: Scope;\n}\n\nfunction isInType(path: NodePath) {\n  do {\n    switch (path.parent.type) {\n      case \"TSTypeAnnotation\":\n      case \"TSTypeAliasDeclaration\":\n      case \"TSTypeReference\":\n      case \"TypeAnnotation\":\n      case \"TypeAlias\":\n        return true;\n      case \"ExportSpecifier\":\n        return (\n          (\n            path.parentPath.parent as\n              | t.ExportDefaultDeclaration\n              | t.ExportNamedDeclaration\n          ).exportKind === \"type\"\n        );\n      default:\n        if (path.parentPath.isStatement() || path.parentPath.isExpression()) {\n          return false;\n        }\n    }\n  } while ((path = path.parentPath));\n}\n\nexport default function rewriteLiveReferences(\n  programPath: NodePath<t.Program>,\n  metadata: ModuleMetadata,\n) {\n  const imported = new Map();\n  const exported = new Map();\n  const requeueInParent = (path: NodePath) => {\n    // Manually re-queue `exports.default =` expressions so that the ES3\n    // transform has an opportunity to convert them. Ideally this would\n    // happen automatically from the replaceWith above. See #4140 for\n    // more info.\n    programPath.requeue(path);\n  };\n\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n\n    exportMeta.push(...data.names);\n  }\n\n  // Rewrite initialization of bindings to update exports.\n  const rewriteBindingInitVisitorState: RewriteBindingInitVisitorState = {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported, // local name => exported name list\n  };\n  programPath.traverse(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    rewriteBindingInitVisitor,\n    rewriteBindingInitVisitorState,\n  );\n\n  simplifyAccess(\n    programPath,\n    // NOTE(logan): The 'Array.from' calls are to make this code with in loose mode.\n    new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]),\n    false,\n  );\n\n  // Rewrite reads/writes from imports and exports to have the correct behavior.\n  const rewriteReferencesVisitorState: RewriteReferencesVisitorState = {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported, // local / import\n    exported, // local name => exported name list\n    buildImportReference: ([source, importName, localName], identNode) => {\n      const meta = metadata.source.get(source);\n      meta.referenced = true;\n\n      if (localName) {\n        if (meta.lazy) {\n          identNode = callExpression(\n            // @ts-expect-error Fixme: we should handle the case when identNode is a JSXIdentifier\n            identNode,\n            [],\n          );\n        }\n        return identNode;\n      }\n\n      let namespace: t.Expression = identifier(meta.name);\n      if (meta.lazy) namespace = callExpression(namespace, []);\n\n      if (importName === \"default\" && meta.interop === \"node-default\") {\n        return namespace;\n      }\n\n      const computed = metadata.stringSpecifiers.has(importName);\n\n      return memberExpression(\n        namespace,\n        computed ? stringLiteral(importName) : identifier(importName),\n        computed,\n      );\n    },\n  };\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);\n}\n\n/**\n * A visitor to inject export update statements during binding initialization.\n */\nconst rewriteBindingInitVisitor: Visitor<RewriteBindingInitVisitorState> = {\n  Scope(path) {\n    path.skip();\n  },\n  ClassDeclaration(path) {\n    const { requeueInParent, exported, metadata } = this;\n\n    const { id } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n\n    const exportNames = exported.get(localName) || [];\n    if (exportNames.length > 0) {\n      const statement = expressionStatement(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        buildBindingExportAssignmentExpression(\n          metadata,\n          exportNames,\n          identifier(localName),\n          path.scope,\n        ),\n      );\n      // @ts-expect-error todo(flow->ts): avoid mutations\n      statement._blockHoist = path.node._blockHoist;\n\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n  VariableDeclaration(path) {\n    const { requeueInParent, exported, metadata } = this;\n\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {\n      const exportNames = exported.get(localName) || [];\n\n      if (exportNames.length > 0) {\n        const statement = expressionStatement(\n          // eslint-disable-next-line @typescript-eslint/no-use-before-define\n          buildBindingExportAssignmentExpression(\n            metadata,\n            exportNames,\n            identifier(localName),\n            path.scope,\n          ),\n        );\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        statement._blockHoist = path.node._blockHoist;\n\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  },\n};\n\nconst buildBindingExportAssignmentExpression = (\n  metadata: ModuleMetadata,\n  exportNames: string[],\n  localExpr: t.Expression,\n  scope: Scope,\n) => {\n  const exportsObjectName = metadata.exportName;\n  for (\n    let currentScope = scope;\n    currentScope != null;\n    currentScope = currentScope.parent\n  ) {\n    if (currentScope.hasOwnBinding(exportsObjectName)) {\n      currentScope.rename(exportsObjectName);\n    }\n  }\n  return (exportNames || []).reduce((expr, exportName) => {\n    // class Foo {} export { Foo, Foo as Bar };\n    // as\n    // class Foo {} exports.Foo = exports.Bar = Foo;\n    const { stringSpecifiers } = metadata;\n    const computed = stringSpecifiers.has(exportName);\n    return assignmentExpression(\n      \"=\",\n      memberExpression(\n        identifier(exportsObjectName),\n        computed ? stringLiteral(exportName) : identifier(exportName),\n        /* computed */ computed,\n      ),\n      expr,\n    );\n  }, localExpr);\n};\n\nconst buildImportThrow = (localName: string) => {\n  return template.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\n\nconst rewriteReferencesVisitor: Visitor<RewriteReferencesVisitorState> = {\n  ReferencedIdentifier(path) {\n    const { seen, buildImportReference, scope, imported, requeueInParent } =\n      this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n\n    const localName = path.node.name;\n\n    const importData = imported.get(localName);\n    if (importData) {\n      if (isInType(path)) {\n        throw path.buildCodeFrameError(\n          `Cannot transform the imported binding \"${localName}\" since it's also used in a type annotation. ` +\n            `Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`,\n        );\n      }\n\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = scope.getBinding(localName);\n\n      // redeclared in this scope\n      if (rootBinding !== localBinding) return;\n\n      const ref = buildImportReference(importData, path.node);\n\n      // Preserve the binding location so that sourcemaps are nicer.\n      ref.loc = path.node.loc;\n\n      if (\n        (path.parentPath.isCallExpression({ callee: path.node }) ||\n          path.parentPath.isOptionalCallExpression({ callee: path.node }) ||\n          path.parentPath.isTaggedTemplateExpression({ tag: path.node })) &&\n        isMemberExpression(ref)\n      ) {\n        path.replaceWith(sequenceExpression([numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {\n        const { object, property } = ref;\n        path.replaceWith(\n          jsxMemberExpression(\n            // @ts-expect-error todo(flow->ts): possible bug `object` might not have a name\n            jsxIdentifier(object.name),\n            // @ts-expect-error todo(flow->ts): possible bug `property` might not have a name\n            jsxIdentifier(property.name),\n          ),\n        );\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n\n      // The path could have been replaced with an identifier that would\n      // otherwise be re-visited, so we skip processing its children.\n      path.skip();\n    }\n  },\n\n  UpdateExpression(path) {\n    const {\n      scope,\n      seen,\n      imported,\n      exported,\n      requeueInParent,\n      buildImportReference,\n    } = this;\n\n    if (seen.has(path.node)) return;\n\n    seen.add(path.node);\n\n    const arg = path.get(\"argument\");\n\n    // No change needed\n    if (arg.isMemberExpression()) return;\n\n    const update = path.node;\n\n    if (arg.isIdentifier()) {\n      const localName = arg.node.name;\n\n      // redeclared in this scope\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      const exportedNames = exported.get(localName);\n      const importData = imported.get(localName);\n\n      if (exportedNames?.length > 0 || importData) {\n        if (importData) {\n          path.replaceWith(\n            assignmentExpression(\n              update.operator[0] + \"=\",\n              buildImportReference(importData, arg.node),\n              buildImportThrow(localName),\n            ),\n          );\n        } else if (update.prefix) {\n          // ++foo\n          // =>   exports.foo = ++foo\n          path.replaceWith(\n            buildBindingExportAssignmentExpression(\n              this.metadata,\n              exportedNames,\n              cloneNode(update),\n              path.scope,\n            ),\n          );\n        } else {\n          // foo++\n          // =>   (ref = i++, exports.i = i, ref)\n          const ref = scope.generateDeclaredUidIdentifier(localName);\n\n          path.replaceWith(\n            sequenceExpression([\n              assignmentExpression(\"=\", cloneNode(ref), cloneNode(update)),\n              buildBindingExportAssignmentExpression(\n                this.metadata,\n                exportedNames,\n                identifier(localName),\n                path.scope,\n              ),\n              cloneNode(ref),\n            ]),\n          );\n        }\n      }\n    }\n\n    requeueInParent(path);\n    path.skip();\n  },\n\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference,\n      } = this;\n\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n\n      const left = path.get(\"left\");\n\n      // No change needed\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        // Simple update-assign foo += 1; export { foo };\n        // =>   exports.foo =  (foo += 1);\n        const localName = left.node.name;\n\n        // redeclared in this scope\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n        if (exportedNames?.length > 0 || importData) {\n          assert(path.node.operator === \"=\", \"Path was not simplified\");\n\n          const assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, left.node);\n\n            assignment.right = sequenceExpression([\n              assignment.right,\n              buildImportThrow(localName),\n            ]);\n          }\n\n          path.replaceWith(\n            buildBindingExportAssignmentExpression(\n              this.metadata,\n              exportedNames,\n              assignment,\n              path.scope,\n            ),\n          );\n          requeueInParent(path);\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(\n          localName =>\n            scope.getBinding(localName) === path.scope.getBinding(localName),\n        );\n        const id = programScopeIds.find(localName => imported.has(localName));\n\n        if (id) {\n          path.node.right = sequenceExpression([\n            path.node.right,\n            buildImportThrow(id),\n          ]);\n        }\n\n        // Complex ({a, b, c} = {}); export { a, c };\n        // =>   ({a, b, c} = {}), (exports.a = a, exports.c = c);\n        const items: t.Expression[] = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n          if (exportedNames.length > 0) {\n            items.push(\n              buildBindingExportAssignmentExpression(\n                this.metadata,\n                exportedNames,\n                identifier(localName),\n                path.scope,\n              ),\n            );\n          }\n        });\n\n        if (items.length > 0) {\n          let node: t.Node = sequenceExpression(items);\n          if (path.parentPath.isExpressionStatement()) {\n            node = expressionStatement(node);\n            // @ts-expect-error todo(flow->ts): avoid mutations\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    },\n  },\n  \"ForOfStatement|ForInStatement\"(\n    path: NodePath<t.ForOfStatement | t.ForInStatement>,\n  ) {\n    const { scope, node } = path;\n    const { left } = node;\n    const { exported, imported, scope: programScope } = this;\n\n    if (!isVariableDeclaration(left)) {\n      let didTransformExport = false,\n        importConstViolationName;\n      const loopBodyScope = path.get(\"body\").scope;\n      for (const name of Object.keys(getOuterBindingIdentifiers(left))) {\n        if (programScope.getBinding(name) === scope.getBinding(name)) {\n          if (exported.has(name)) {\n            didTransformExport = true;\n            if (loopBodyScope.hasOwnBinding(name)) {\n              loopBodyScope.rename(name);\n            }\n          }\n          if (imported.has(name) && !importConstViolationName) {\n            importConstViolationName = name;\n          }\n        }\n      }\n      if (!didTransformExport && !importConstViolationName) {\n        return;\n      }\n\n      path.ensureBlock();\n      const bodyPath = path.get(\"body\");\n\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      path\n        .get(\"left\")\n        .replaceWith(\n          variableDeclaration(\"let\", [\n            variableDeclarator(cloneNode(newLoopId)),\n          ]),\n        );\n      scope.registerDeclaration(path.get(\"left\"));\n\n      if (didTransformExport) {\n        bodyPath.unshiftContainer(\n          \"body\",\n          expressionStatement(assignmentExpression(\"=\", left, newLoopId)),\n        );\n      }\n      if (importConstViolationName) {\n        bodyPath.unshiftContainer(\n          \"body\",\n          expressionStatement(buildImportThrow(importConstViolationName)),\n        );\n      }\n    }\n  },\n};\n"],"mappings":";;;;;;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,EAAA,GAAAD,OAAA;AAmBA,IAAAE,SAAA,GAAAF,OAAA;AAEA,IAAAG,mBAAA,GAAAH,OAAA;AAAyD;EApBvDI,oBAAoB;EACpBC,cAAc;EACdC,SAAS;EACTC,mBAAmB;EACnBC,0BAA0B;EAC1BC,UAAU;EACVC,kBAAkB;EAClBC,qBAAqB;EACrBC,aAAa;EACbC,mBAAmB;EACnBC,gBAAgB;EAChBC,cAAc;EACdC,kBAAkB;EAClBC,aAAa;EACbC,mBAAmB;EACnBC;AAAkB,IAAAlB,EAAA;AA6BpB,SAASmB,QAAQA,CAACC,IAAc,EAAE;EAChC,GAAG;IACD,QAAQA,IAAI,CAACC,MAAM,CAACC,IAAI;MACtB,KAAK,kBAAkB;MACvB,KAAK,wBAAwB;MAC7B,KAAK,iBAAiB;MACtB,KAAK,gBAAgB;MACrB,KAAK,WAAW;QACd,OAAO,IAAI;MACb,KAAK,iBAAiB;QACpB,OAEIF,IAAI,CAACG,UAAU,CAACF,MAAM,CAGtBG,UAAU,KAAK,MAAM;MAE3B;QACE,IAAIJ,IAAI,CAACG,UAAU,CAACE,WAAW,EAAE,IAAIL,IAAI,CAACG,UAAU,CAACG,YAAY,EAAE,EAAE;UACnE,OAAO,KAAK;QACd;IAAA;EAEN,CAAC,QAASN,IAAI,GAAGA,IAAI,CAACG,UAAU;AAClC;AAEe,SAASI,qBAAqBA,CAC3CC,WAAgC,EAChCC,QAAwB,EACxB;EACA,MAAMC,QAAQ,GAAG,IAAIC,GAAG,EAAE;EAC1B,MAAMC,QAAQ,GAAG,IAAID,GAAG,EAAE;EAC1B,MAAME,eAAe,GAAIb,IAAc,IAAK;IAK1CQ,WAAW,CAACM,OAAO,CAACd,IAAI,CAAC;EAC3B,CAAC;EAED,KAAK,MAAM,CAACe,MAAM,EAAEC,IAAI,CAAC,IAAIP,QAAQ,CAACM,MAAM,EAAE;IAC5C,KAAK,MAAM,CAACE,SAAS,EAAEC,UAAU,CAAC,IAAIF,IAAI,CAACG,OAAO,EAAE;MAClDT,QAAQ,CAACU,GAAG,CAACH,SAAS,EAAE,CAACF,MAAM,EAAEG,UAAU,EAAE,IAAI,CAAC,CAAC;IACrD;IACA,KAAK,MAAMD,SAAS,IAAID,IAAI,CAACK,gBAAgB,EAAE;MAC7CX,QAAQ,CAACU,GAAG,CAACH,SAAS,EAAE,CAACF,MAAM,EAAE,IAAI,EAAEE,SAAS,CAAC,CAAC;IACpD;EACF;EAEA,KAAK,MAAM,CAACK,KAAK,EAAEN,IAAI,CAAC,IAAIP,QAAQ,CAACa,KAAK,EAAE;IAC1C,IAAIC,UAAU,GAAGX,QAAQ,CAACY,GAAG,CAACF,KAAK,CAAC;IACpC,IAAI,CAACC,UAAU,EAAE;MACfA,UAAU,GAAG,EAAE;MACfX,QAAQ,CAACQ,GAAG,CAACE,KAAK,EAAEC,UAAU,CAAC;IACjC;IAEAA,UAAU,CAACE,IAAI,CAAC,GAAGT,IAAI,CAACU,KAAK,CAAC;EAChC;EAGA,MAAMC,8BAA8D,GAAG;IACrElB,QAAQ;IACRI,eAAe;IACfe,KAAK,EAAEpB,WAAW,CAACoB,KAAK;IACxBhB;EACF,CAAC;EACDJ,WAAW,CAACqB,QAAQ,CAElBC,yBAAyB,EACzBH,8BAA8B,CAC/B;EAED,IAAA7C,mBAAA,CAAAiD,OAAc,EACZvB,WAAW,EAEX,IAAIwB,GAAG,CAAC,CAAC,GAAGC,KAAK,CAACC,IAAI,CAACxB,QAAQ,CAACyB,IAAI,EAAE,CAAC,EAAE,GAAGF,KAAK,CAACC,IAAI,CAACtB,QAAQ,CAACuB,IAAI,EAAE,CAAC,CAAC,CAAC,EACzE,KAAK,CACN;EAGD,MAAMC,6BAA4D,GAAG;IACnEC,IAAI,EAAE,IAAIC,OAAO,EAAE;IACnB7B,QAAQ;IACRI,eAAe;IACfe,KAAK,EAAEpB,WAAW,CAACoB,KAAK;IACxBlB,QAAQ;IACRE,QAAQ;IACR2B,oBAAoB,EAAEA,CAAC,CAACxB,MAAM,EAAEG,UAAU,EAAED,SAAS,CAAC,EAAEuB,SAAS,KAAK;MACpE,MAAMC,IAAI,GAAGhC,QAAQ,CAACM,MAAM,CAACS,GAAG,CAACT,MAAM,CAAC;MACxC0B,IAAI,CAACC,UAAU,GAAG,IAAI;MAEtB,IAAIzB,SAAS,EAAE;QACb,IAAIwB,IAAI,CAACE,IAAI,EAAE;UACbH,SAAS,GAAGxD,cAAc,CAExBwD,SAAS,EACT,EAAE,CACH;QACH;QACA,OAAOA,SAAS;MAClB;MAEA,IAAII,SAAuB,GAAGxD,UAAU,CAACqD,IAAI,CAACI,IAAI,CAAC;MACnD,IAAIJ,IAAI,CAACE,IAAI,EAAEC,SAAS,GAAG5D,cAAc,CAAC4D,SAAS,EAAE,EAAE,CAAC;MAExD,IAAI1B,UAAU,KAAK,SAAS,IAAIuB,IAAI,CAACK,OAAO,KAAK,cAAc,EAAE;QAC/D,OAAOF,SAAS;MAClB;MAEA,MAAMG,QAAQ,GAAGtC,QAAQ,CAACuC,gBAAgB,CAACC,GAAG,CAAC/B,UAAU,CAAC;MAE1D,OAAOzB,gBAAgB,CACrBmD,SAAS,EACTG,QAAQ,GAAGnD,aAAa,CAACsB,UAAU,CAAC,GAAG9B,UAAU,CAAC8B,UAAU,CAAC,EAC7D6B,QAAQ,CACT;IACH;EACF,CAAC;EAEDvC,WAAW,CAACqB,QAAQ,CAACqB,wBAAwB,EAAEd,6BAA6B,CAAC;AAC/E;AAKA,MAAMN,yBAAkE,GAAG;EACzEqB,KAAKA,CAACnD,IAAI,EAAE;IACVA,IAAI,CAACoD,IAAI,EAAE;EACb,CAAC;EACDC,gBAAgBA,CAACrD,IAAI,EAAE;IACrB,MAAM;MAAEa,eAAe;MAAED,QAAQ;MAAEH;IAAS,CAAC,GAAG,IAAI;IAEpD,MAAM;MAAE6C;IAAG,CAAC,GAAGtD,IAAI,CAACuD,IAAI;IACxB,IAAI,CAACD,EAAE,EAAE,MAAM,IAAIE,KAAK,CAAC,+BAA+B,CAAC;IACzD,MAAMvC,SAAS,GAAGqC,EAAE,CAACT,IAAI;IAEzB,MAAMY,WAAW,GAAG7C,QAAQ,CAACY,GAAG,CAACP,SAAS,CAAC,IAAI,EAAE;IACjD,IAAIwC,WAAW,CAACC,MAAM,GAAG,CAAC,EAAE;MAC1B,MAAMC,SAAS,GAAGzE,mBAAmB,CAEnC0E,sCAAsC,CACpCnD,QAAQ,EACRgD,WAAW,EACXrE,UAAU,CAAC6B,SAAS,CAAC,EACrBjB,IAAI,CAAC4B,KAAK,CACX,CACF;MAED+B,SAAS,CAACE,WAAW,GAAG7D,IAAI,CAACuD,IAAI,CAACM,WAAW;MAE7ChD,eAAe,CAACb,IAAI,CAAC8D,WAAW,CAACH,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IACjD;EACF,CAAC;EACDI,mBAAmBA,CAAC/D,IAAI,EAAE;IACxB,MAAM;MAAEa,eAAe;MAAED,QAAQ;MAAEH;IAAS,CAAC,GAAG,IAAI;IAEpDuD,MAAM,CAAC7B,IAAI,CAACnC,IAAI,CAACb,0BAA0B,EAAE,CAAC,CAAC8E,OAAO,CAAChD,SAAS,IAAI;MAClE,MAAMwC,WAAW,GAAG7C,QAAQ,CAACY,GAAG,CAACP,SAAS,CAAC,IAAI,EAAE;MAEjD,IAAIwC,WAAW,CAACC,MAAM,GAAG,CAAC,EAAE;QAC1B,MAAMC,SAAS,GAAGzE,mBAAmB,CAEnC0E,sCAAsC,CACpCnD,QAAQ,EACRgD,WAAW,EACXrE,UAAU,CAAC6B,SAAS,CAAC,EACrBjB,IAAI,CAAC4B,KAAK,CACX,CACF;QAED+B,SAAS,CAACE,WAAW,GAAG7D,IAAI,CAACuD,IAAI,CAACM,WAAW;QAE7ChD,eAAe,CAACb,IAAI,CAAC8D,WAAW,CAACH,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;MACjD;IACF,CAAC,CAAC;EACJ;AACF,CAAC;AAED,MAAMC,sCAAsC,GAAGA,CAC7CnD,QAAwB,EACxBgD,WAAqB,EACrBS,SAAuB,EACvBtC,KAAY,KACT;EACH,MAAMuC,iBAAiB,GAAG1D,QAAQ,CAAC2D,UAAU;EAC7C,KACE,IAAIC,YAAY,GAAGzC,KAAK,EACxByC,YAAY,IAAI,IAAI,EACpBA,YAAY,GAAGA,YAAY,CAACpE,MAAM,EAClC;IACA,IAAIoE,YAAY,CAACC,aAAa,CAACH,iBAAiB,CAAC,EAAE;MACjDE,YAAY,CAACE,MAAM,CAACJ,iBAAiB,CAAC;IACxC;EACF;EACA,OAAO,CAACV,WAAW,IAAI,EAAE,EAAEe,MAAM,CAAC,CAACC,IAAI,EAAEL,UAAU,KAAK;IAItD,MAAM;MAAEpB;IAAiB,CAAC,GAAGvC,QAAQ;IACrC,MAAMsC,QAAQ,GAAGC,gBAAgB,CAACC,GAAG,CAACmB,UAAU,CAAC;IACjD,OAAOrF,oBAAoB,CACzB,GAAG,EACHU,gBAAgB,CACdL,UAAU,CAAC+E,iBAAiB,CAAC,EAC7BpB,QAAQ,GAAGnD,aAAa,CAACwE,UAAU,CAAC,GAAGhF,UAAU,CAACgF,UAAU,CAAC,EAC9CrB,QAAQ,CACxB,EACD0B,IAAI,CACL;EACH,CAAC,EAAEP,SAAS,CAAC;AACf,CAAC;AAED,MAAMQ,gBAAgB,GAAIzD,SAAiB,IAAK;EAC9C,OAAOpC,SAAA,CAAAkD,OAAQ,CAAC4C,UAAU,CAACC,GAAI;AACjC;AACA,+BAA+B3D,SAAU;AACzC;AACA,GAAG;AACH,CAAC;AAED,MAAMiC,wBAAgE,GAAG;EACvE2B,oBAAoBA,CAAC7E,IAAI,EAAE;IACzB,MAAM;MAAEqC,IAAI;MAAEE,oBAAoB;MAAEX,KAAK;MAAElB,QAAQ;MAAEG;IAAgB,CAAC,GACpE,IAAI;IACN,IAAIwB,IAAI,CAACY,GAAG,CAACjD,IAAI,CAACuD,IAAI,CAAC,EAAE;IACzBlB,IAAI,CAACyC,GAAG,CAAC9E,IAAI,CAACuD,IAAI,CAAC;IAEnB,MAAMtC,SAAS,GAAGjB,IAAI,CAACuD,IAAI,CAACV,IAAI;IAEhC,MAAMkC,UAAU,GAAGrE,QAAQ,CAACc,GAAG,CAACP,SAAS,CAAC;IAC1C,IAAI8D,UAAU,EAAE;MACd,IAAIhF,QAAQ,CAACC,IAAI,CAAC,EAAE;QAClB,MAAMA,IAAI,CAACgF,mBAAmB,CAC3B,0CAAyC/D,SAAU,+CAA8C,GAC/F,qFAAoF,CACxF;MACH;MAEA,MAAMgE,YAAY,GAAGjF,IAAI,CAAC4B,KAAK,CAACsD,UAAU,CAACjE,SAAS,CAAC;MACrD,MAAMkE,WAAW,GAAGvD,KAAK,CAACsD,UAAU,CAACjE,SAAS,CAAC;MAG/C,IAAIkE,WAAW,KAAKF,YAAY,EAAE;MAElC,MAAMG,GAAG,GAAG7C,oBAAoB,CAACwC,UAAU,EAAE/E,IAAI,CAACuD,IAAI,CAAC;MAGvD6B,GAAG,CAACC,GAAG,GAAGrF,IAAI,CAACuD,IAAI,CAAC8B,GAAG;MAEvB,IACE,CAACrF,IAAI,CAACG,UAAU,CAACmF,gBAAgB,CAAC;QAAEC,MAAM,EAAEvF,IAAI,CAACuD;MAAK,CAAC,CAAC,IACtDvD,IAAI,CAACG,UAAU,CAACqF,wBAAwB,CAAC;QAAED,MAAM,EAAEvF,IAAI,CAACuD;MAAK,CAAC,CAAC,IAC/DvD,IAAI,CAACG,UAAU,CAACsF,0BAA0B,CAAC;QAAEC,GAAG,EAAE1F,IAAI,CAACuD;MAAK,CAAC,CAAC,KAChElE,kBAAkB,CAAC+F,GAAG,CAAC,EACvB;QACApF,IAAI,CAAC2F,WAAW,CAAChG,kBAAkB,CAAC,CAACD,cAAc,CAAC,CAAC,CAAC,EAAE0F,GAAG,CAAC,CAAC,CAAC;MAChE,CAAC,MAAM,IAAIpF,IAAI,CAAC4F,eAAe,EAAE,IAAIvG,kBAAkB,CAAC+F,GAAG,CAAC,EAAE;QAC5D,MAAM;UAAES,MAAM;UAAEC;QAAS,CAAC,GAAGV,GAAG;QAChCpF,IAAI,CAAC2F,WAAW,CACdnG,mBAAmB,CAEjBD,aAAa,CAACsG,MAAM,CAAChD,IAAI,CAAC,EAE1BtD,aAAa,CAACuG,QAAQ,CAACjD,IAAI,CAAC,CAC7B,CACF;MACH,CAAC,MAAM;QACL7C,IAAI,CAAC2F,WAAW,CAACP,GAAG,CAAC;MACvB;MAEAvE,eAAe,CAACb,IAAI,CAAC;MAIrBA,IAAI,CAACoD,IAAI,EAAE;IACb;EACF,CAAC;EAED2C,gBAAgBA,CAAC/F,IAAI,EAAE;IACrB,MAAM;MACJ4B,KAAK;MACLS,IAAI;MACJ3B,QAAQ;MACRE,QAAQ;MACRC,eAAe;MACf0B;IACF,CAAC,GAAG,IAAI;IAER,IAAIF,IAAI,CAACY,GAAG,CAACjD,IAAI,CAACuD,IAAI,CAAC,EAAE;IAEzBlB,IAAI,CAACyC,GAAG,CAAC9E,IAAI,CAACuD,IAAI,CAAC;IAEnB,MAAMyC,GAAG,GAAGhG,IAAI,CAACwB,GAAG,CAAC,UAAU,CAAC;IAGhC,IAAIwE,GAAG,CAAC3G,kBAAkB,EAAE,EAAE;IAE9B,MAAM4G,MAAM,GAAGjG,IAAI,CAACuD,IAAI;IAExB,IAAIyC,GAAG,CAACE,YAAY,EAAE,EAAE;MACtB,MAAMjF,SAAS,GAAG+E,GAAG,CAACzC,IAAI,CAACV,IAAI;MAG/B,IAAIjB,KAAK,CAACsD,UAAU,CAACjE,SAAS,CAAC,KAAKjB,IAAI,CAAC4B,KAAK,CAACsD,UAAU,CAACjE,SAAS,CAAC,EAAE;QACpE;MACF;MAEA,MAAMkF,aAAa,GAAGvF,QAAQ,CAACY,GAAG,CAACP,SAAS,CAAC;MAC7C,MAAM8D,UAAU,GAAGrE,QAAQ,CAACc,GAAG,CAACP,SAAS,CAAC;MAE1C,IAAI,CAAAkF,aAAa,oBAAbA,aAAa,CAAEzC,MAAM,IAAG,CAAC,IAAIqB,UAAU,EAAE;QAC3C,IAAIA,UAAU,EAAE;UACd/E,IAAI,CAAC2F,WAAW,CACd5G,oBAAoB,CAClBkH,MAAM,CAACG,QAAQ,CAAC,CAAC,CAAC,GAAG,GAAG,EACxB7D,oBAAoB,CAACwC,UAAU,EAAEiB,GAAG,CAACzC,IAAI,CAAC,EAC1CmB,gBAAgB,CAACzD,SAAS,CAAC,CAC5B,CACF;QACH,CAAC,MAAM,IAAIgF,MAAM,CAACI,MAAM,EAAE;UAGxBrG,IAAI,CAAC2F,WAAW,CACd/B,sCAAsC,CACpC,IAAI,CAACnD,QAAQ,EACb0F,aAAa,EACblH,SAAS,CAACgH,MAAM,CAAC,EACjBjG,IAAI,CAAC4B,KAAK,CACX,CACF;QACH,CAAC,MAAM;UAGL,MAAMwD,GAAG,GAAGxD,KAAK,CAAC0E,6BAA6B,CAACrF,SAAS,CAAC;UAE1DjB,IAAI,CAAC2F,WAAW,CACdhG,kBAAkB,CAAC,CACjBZ,oBAAoB,CAAC,GAAG,EAAEE,SAAS,CAACmG,GAAG,CAAC,EAAEnG,SAAS,CAACgH,MAAM,CAAC,CAAC,EAC5DrC,sCAAsC,CACpC,IAAI,CAACnD,QAAQ,EACb0F,aAAa,EACb/G,UAAU,CAAC6B,SAAS,CAAC,EACrBjB,IAAI,CAAC4B,KAAK,CACX,EACD3C,SAAS,CAACmG,GAAG,CAAC,CACf,CAAC,CACH;QACH;MACF;IACF;IAEAvE,eAAe,CAACb,IAAI,CAAC;IACrBA,IAAI,CAACoD,IAAI,EAAE;EACb,CAAC;EAEDmD,oBAAoB,EAAE;IACpBC,IAAIA,CAACxG,IAAI,EAAE;MACT,MAAM;QACJ4B,KAAK;QACLS,IAAI;QACJ3B,QAAQ;QACRE,QAAQ;QACRC,eAAe;QACf0B;MACF,CAAC,GAAG,IAAI;MAER,IAAIF,IAAI,CAACY,GAAG,CAACjD,IAAI,CAACuD,IAAI,CAAC,EAAE;MACzBlB,IAAI,CAACyC,GAAG,CAAC9E,IAAI,CAACuD,IAAI,CAAC;MAEnB,MAAMkD,IAAI,GAAGzG,IAAI,CAACwB,GAAG,CAAC,MAAM,CAAC;MAG7B,IAAIiF,IAAI,CAACpH,kBAAkB,EAAE,EAAE;MAE/B,IAAIoH,IAAI,CAACP,YAAY,EAAE,EAAE;QAGvB,MAAMjF,SAAS,GAAGwF,IAAI,CAAClD,IAAI,CAACV,IAAI;QAGhC,IAAIjB,KAAK,CAACsD,UAAU,CAACjE,SAAS,CAAC,KAAKjB,IAAI,CAAC4B,KAAK,CAACsD,UAAU,CAACjE,SAAS,CAAC,EAAE;UACpE;QACF;QAEA,MAAMkF,aAAa,GAAGvF,QAAQ,CAACY,GAAG,CAACP,SAAS,CAAC;QAC7C,MAAM8D,UAAU,GAAGrE,QAAQ,CAACc,GAAG,CAACP,SAAS,CAAC;QAC1C,IAAI,CAAAkF,aAAa,oBAAbA,aAAa,CAAEzC,MAAM,IAAG,CAAC,IAAIqB,UAAU,EAAE;UAC3CrG,OAAM,CAACsB,IAAI,CAACuD,IAAI,CAAC6C,QAAQ,KAAK,GAAG,EAAE,yBAAyB,CAAC;UAE7D,MAAMM,UAAU,GAAG1G,IAAI,CAACuD,IAAI;UAE5B,IAAIwB,UAAU,EAAE;YACd2B,UAAU,CAACD,IAAI,GAAGlE,oBAAoB,CAACwC,UAAU,EAAE0B,IAAI,CAAClD,IAAI,CAAC;YAE7DmD,UAAU,CAACC,KAAK,GAAGhH,kBAAkB,CAAC,CACpC+G,UAAU,CAACC,KAAK,EAChBjC,gBAAgB,CAACzD,SAAS,CAAC,CAC5B,CAAC;UACJ;UAEAjB,IAAI,CAAC2F,WAAW,CACd/B,sCAAsC,CACpC,IAAI,CAACnD,QAAQ,EACb0F,aAAa,EACbO,UAAU,EACV1G,IAAI,CAAC4B,KAAK,CACX,CACF;UACDf,eAAe,CAACb,IAAI,CAAC;QACvB;MACF,CAAC,MAAM;QACL,MAAM4G,GAAG,GAAGH,IAAI,CAACtH,0BAA0B,EAAE;QAC7C,MAAM0H,eAAe,GAAG7C,MAAM,CAAC7B,IAAI,CAACyE,GAAG,CAAC,CAACE,MAAM,CAC7C7F,SAAS,IACPW,KAAK,CAACsD,UAAU,CAACjE,SAAS,CAAC,KAAKjB,IAAI,CAAC4B,KAAK,CAACsD,UAAU,CAACjE,SAAS,CAAC,CACnE;QACD,MAAMqC,EAAE,GAAGuD,eAAe,CAACE,IAAI,CAAC9F,SAAS,IAAIP,QAAQ,CAACuC,GAAG,CAAChC,SAAS,CAAC,CAAC;QAErE,IAAIqC,EAAE,EAAE;UACNtD,IAAI,CAACuD,IAAI,CAACoD,KAAK,GAAGhH,kBAAkB,CAAC,CACnCK,IAAI,CAACuD,IAAI,CAACoD,KAAK,EACfjC,gBAAgB,CAACpB,EAAE,CAAC,CACrB,CAAC;QACJ;QAIA,MAAM0D,KAAqB,GAAG,EAAE;QAChCH,eAAe,CAAC5C,OAAO,CAAChD,SAAS,IAAI;UACnC,MAAMkF,aAAa,GAAGvF,QAAQ,CAACY,GAAG,CAACP,SAAS,CAAC,IAAI,EAAE;UACnD,IAAIkF,aAAa,CAACzC,MAAM,GAAG,CAAC,EAAE;YAC5BsD,KAAK,CAACvF,IAAI,CACRmC,sCAAsC,CACpC,IAAI,CAACnD,QAAQ,EACb0F,aAAa,EACb/G,UAAU,CAAC6B,SAAS,CAAC,EACrBjB,IAAI,CAAC4B,KAAK,CACX,CACF;UACH;QACF,CAAC,CAAC;QAEF,IAAIoF,KAAK,CAACtD,MAAM,GAAG,CAAC,EAAE;UACpB,IAAIH,IAAY,GAAG5D,kBAAkB,CAACqH,KAAK,CAAC;UAC5C,IAAIhH,IAAI,CAACG,UAAU,CAAC8G,qBAAqB,EAAE,EAAE;YAC3C1D,IAAI,GAAGrE,mBAAmB,CAACqE,IAAI,CAAC;YAEhCA,IAAI,CAACM,WAAW,GAAG7D,IAAI,CAACG,UAAU,CAACoD,IAAI,CAACM,WAAW;UACrD;UAEA,MAAMF,SAAS,GAAG3D,IAAI,CAAC8D,WAAW,CAACP,IAAI,CAAC,CAAC,CAAC,CAAC;UAC3C1C,eAAe,CAAC8C,SAAS,CAAC;QAC5B;MACF;IACF;EACF,CAAC;EACD,+BAA+BuD,CAC7BlH,IAAmD,EACnD;IACA,MAAM;MAAE4B,KAAK;MAAE2B;IAAK,CAAC,GAAGvD,IAAI;IAC5B,MAAM;MAAEyG;IAAK,CAAC,GAAGlD,IAAI;IACrB,MAAM;MAAE3C,QAAQ;MAAEF,QAAQ;MAAEkB,KAAK,EAAEuF;IAAa,CAAC,GAAG,IAAI;IAExD,IAAI,CAAC7H,qBAAqB,CAACmH,IAAI,CAAC,EAAE;MAChC,IAAIW,kBAAkB,GAAG,KAAK;QAC5BC,wBAAwB;MAC1B,MAAMC,aAAa,GAAGtH,IAAI,CAACwB,GAAG,CAAC,MAAM,CAAC,CAACI,KAAK;MAC5C,KAAK,MAAMiB,IAAI,IAAImB,MAAM,CAAC7B,IAAI,CAAChD,0BAA0B,CAACsH,IAAI,CAAC,CAAC,EAAE;QAChE,IAAIU,YAAY,CAACjC,UAAU,CAACrC,IAAI,CAAC,KAAKjB,KAAK,CAACsD,UAAU,CAACrC,IAAI,CAAC,EAAE;UAC5D,IAAIjC,QAAQ,CAACqC,GAAG,CAACJ,IAAI,CAAC,EAAE;YACtBuE,kBAAkB,GAAG,IAAI;YACzB,IAAIE,aAAa,CAAChD,aAAa,CAACzB,IAAI,CAAC,EAAE;cACrCyE,aAAa,CAAC/C,MAAM,CAAC1B,IAAI,CAAC;YAC5B;UACF;UACA,IAAInC,QAAQ,CAACuC,GAAG,CAACJ,IAAI,CAAC,IAAI,CAACwE,wBAAwB,EAAE;YACnDA,wBAAwB,GAAGxE,IAAI;UACjC;QACF;MACF;MACA,IAAI,CAACuE,kBAAkB,IAAI,CAACC,wBAAwB,EAAE;QACpD;MACF;MAEArH,IAAI,CAACuH,WAAW,EAAE;MAClB,MAAMC,QAAQ,GAAGxH,IAAI,CAACwB,GAAG,CAAC,MAAM,CAAC;MAEjC,MAAMiG,SAAS,GAAG7F,KAAK,CAAC8F,gCAAgC,CAACjB,IAAI,CAAC;MAC9DzG,IAAI,CACDwB,GAAG,CAAC,MAAM,CAAC,CACXmE,WAAW,CACV9F,mBAAmB,CAAC,KAAK,EAAE,CACzBC,kBAAkB,CAACb,SAAS,CAACwI,SAAS,CAAC,CAAC,CACzC,CAAC,CACH;MACH7F,KAAK,CAAC+F,mBAAmB,CAAC3H,IAAI,CAACwB,GAAG,CAAC,MAAM,CAAC,CAAC;MAE3C,IAAI4F,kBAAkB,EAAE;QACtBI,QAAQ,CAACI,gBAAgB,CACvB,MAAM,EACN1I,mBAAmB,CAACH,oBAAoB,CAAC,GAAG,EAAE0H,IAAI,EAAEgB,SAAS,CAAC,CAAC,CAChE;MACH;MACA,IAAIJ,wBAAwB,EAAE;QAC5BG,QAAQ,CAACI,gBAAgB,CACvB,MAAM,EACN1I,mBAAmB,CAACwF,gBAAgB,CAAC2C,wBAAwB,CAAC,CAAC,CAChE;MACH;IACF;EACF;AACF,CAAC"},"metadata":{},"sourceType":"script"}